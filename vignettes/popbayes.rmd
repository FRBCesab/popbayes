---
title: "Get started with popbayes"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Get started with popbayes}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse   = TRUE,
  comment    = "#>",
  fig.width  = 7,
  fig.height = 7,
  out.width  = "100%",
  dpi        = 300
)
```

```{r 'setup', echo = FALSE}
library("popbayes")
```

The goal of the R package `popbayes` is to fit population trajectories over time from counts of individuals collected at various dates and with a variety of methods. It does so under a Bayesian framework where the primary quantity being modeled is the rate of increase between successive years (or any other time unit for that matter, the one used for date). The package can deal with multiple species and multiple locations presented in a single data set, but each **count series** made of the counts relative to one species at one location will be processed independently.

The strength of `popbayes` is to handle, in a single series, counts collected under different types of surveys (aerial vs ground surveys), and estimated by different census methods (total counts, sampling counts, and even guesstimates [i.e. expert estimates]).



<br />

**Before using this package, users need to install the freeware 
[JAGS](https://mcmc-jags.sourceforge.io/).**

<br />


The workflow of `popbayes` consists in three main steps:

1. Formatting data (`format_data()`)
2. Fitting trends (`fit_trend()`)
3. Visualizing results (`plot_trend()`)

The package also provides a lot of functions to handle individual count series 
and model outputs. The following figure shows a more complete usage of the 
workflow.


<br />


```{r, echo = FALSE, out.width = "100%", fig.cap = "Framework of the popbayes package", fig.align = 'center'}
knitr::include_graphics("docs/popbayes-diagram.png")
```


<br />



## The Garamba dataset



The package `popbayes` comes with an example dataset: `garamba`. It contains 
counts of individuals from 10 African mammal species surveyed in the Garamba 
National Park (Democratic Republic of the Congo) from 1976 to 2017.


<br />

```{r 'load-data'}
data("garamba")
```

<br />

```{r 'print-data', echo = FALSE}
knitr::kable(head(garamba, 20), caption = "The Garamba dataset (first 20 rows)", 
             align = c("c", "l", "c", "c", "c", "r", "r", "r"))
```


<br />


This dataset has a typical structure with a location field (`location`), a 
species name field (`species`), a date field (`year`), and a count
field (`counts`).  

A file with a similar structure in Excel format can be imported in R with...

<br />

**Statistical method**

In addition to the fields `location`, `species`, `year`, and `counts`, a fourth field is **mandatory**: `stat_method`. This field specifies the 
census method that produced the count. It can be `T` for a total 
count, `G` for a guesstimate (i.e. expert estimate), or `S` for a sampling count.

To be usable by the Bayesian model, individual counts are to be accompanied 
by information on precision in the form of a 95% confidence interval. If counts are :

- `T` or `G`, a confidence interval will be computed automatically by the function `format_data()` according respectively to the following formulas:

$$ CI_{(T)} = [\ 0.95 \times counts\ ; 1.20 \times counts\ ] $$
$$ CI_{(G)} = [\ 0.80 \times counts\ ; 1.20 \times counts\ ] $$

- `S`, users **need to specify** a measure of precision. Precision 
is preferably provided in the form of a 95% CI by means of two fields: `lower_ci` 
and `upper_ci` (as in the `garamba` dataset). Alternatively, it may also be given 
in the form of a standard deviation (`sd`), a variance (`var`), or a 
coefficient of variation (`cv`). Note that precision metrics can be different 
between counts. For instance, some `S` counts may have an `sd` value and others 
`lower_ci` and `upper_ci`. In that case, three precision columns would be required
(`lower_ci`, `upper_ci`, and `sd`). 


<br />

**Field method**

Another **optional** column, `field_method`, may be provided. It refers to the 
type of survey used to collect data. This can be `A` for aerial survey or `G` for 
ground survey. This column becomes mandatory as soon as both field methods are present in a series.

The detectability of a species is indeed strongly dependent on the survey method and
each species has its own _preferred field method_, the one that is assumed to provide estimates closer to the truth. So, even if a series is homogeneous relative to the `field method`, it is recommended to provide
the column `field_method` if counts have been collected under the not preferred 
field method. That will force conversion towards the _preferred field method_.


<br />

**Count conversion**

The function `format_data()` will convert counts (and 95% CI bounds) into their 
equivalent in the preferred field method for the species. To this aim, two pieces of information are required :

- `pref_field_method`: the preferred field method for the species (`A` or `G`)
- `conversion_fact`: the multiplicative factor used to convert an aerial count into an equivalent ground count.

The package `popbayes` provides the `conversion_data` data set, which contains
these two pieces of information for 15 African mammal species. 

<br />

```{r 'load-data-2'}
data("conversion_data")
```

<br />

```{r 'print-data-2', echo = FALSE}
knitr::kable(conversion_data[ , c(3, 6, 7, 8)], caption = "Species with count conversion information in popbayes", 
             align = c("l", "c", "c", "r"))
```

<br />

If users work only with species in this table, the package `popbayes` can automatically retrieve the values of `pref_field_method` and `conversion_fact` from the `conversion_data` data set. But for other species, users **need to provide** the information themselves when running `format_data()`. These values can be provided as additional columns of the count data set. Care must then be taken that the same value is consistently repeated for each count of the same species. For users with sufficient command of R, we recommend rather to create an independent additional table similar to `conversion_data` and to pass it to the function `format_data()` as the argument `info`. 

**Note**: Currently `format_data()` takes its information for count conversion from **one source only** with priority given to `info`, then to additional columns in data (if `info` is not provided), and eventually to the `conversion_data` table of the package (when the other two sources are missing). That means that the source with the highest priority must be complete with respect to the species present in data, as it will be used exclusively to any other source. If, say, you use `info`, you cannot expect `format_data()` to retrieve conversion information for a species undocumented in `info` from the `conversion_data` table of the package. However, you can easily construct `info` from a copy of `conversion_data`, which additionally provides a ready template. It suffices to add any species not already in `conversion_data` as shown below.   
Let's assume that we have counts of _Taurotragus oryx_ and  _Taurotragus derbianus_ in addition to other species present in the package `conversion_data` table. We can construct `info` as follows. 

```{r 'create-info'}
## Extract the relevant columns of the package table "conversion_data" ----
info_from_package <- conversion_data[, c("species", "pref_field_method", "conversion_fact")]

## Add the new species ----
new_conversion_info <- data.frame("species"           = c("Taurotragus oryx","Taurotragus derbianus"),
                              "pref_field_method" = "G",
                              "conversion_fact"   = 2.302)

## Append the new species ----
info <- rbind(info_from_package, new_conversion_info)
info
```

<br />

If you do not have conversion information of your own for a new species, you can rely on the conversion information of species with similar characteristics. The package popbayes distinguishes five categories of species:

- **MLB**: Medium-sized Light and Brown species (20-150kg)
- **LLB**: Large Light and Brown species (>150kg)
- **LD**: Large Dark (>150kg)
- **Elephant**
- **Giraffe**

The field `category` of the `conversion_data` table indicates which species belong to each.

<br />



## Checking data


The first thing that the function `format data()` does is to check the validity of the content of the different fields of the count data set. Here we will do that manually on the Garamba dataset for illustration purposes. 

In particular, we need to check `location` and `species` spelling, `year` and `counts` field format, and the `stat_method` and `field_method` categories.


<br />

**Check `location` field**

```{r 'check-location'}
unique(garamba$"location")

sum(is.na(garamba$"location"))   # Are there any missing values?
```

Field **`location`** can be either a `character` or a `factor`. It **cannot** 
contain any `NA` values.


<br />

**Check `species` field**

```{r 'check-species'}
unique(garamba$"species")

sum(is.na(garamba$"species"))   # Are there any missing values?

## Are there species absent from the 'conversion_data' popbayes dataset?
garamba_species <- unique(garamba$"species")
garamba_species[which(!(garamba_species %in% conversion_data$"species"))]
```

Field **`species`** can be either a `character` or a `factor`. It **cannot** 
contain any `NA` values.


<br />

**Check `year` field**

```{r 'check-year'}
is.numeric(garamba$"year")     # Are years in a numerical format?

sum(is.na(garamba$"year"))     # Are there any missing values?

range(garamba$"year")          # What is the temporal extent?
```

Field **`year`** must be a `numeric`. It **cannot** contain any `NA` values. This said, the time unit is arbitrary, and fractional values of years (or another unit) are allowed. As long as numeric values are entered, the package will work.

<br />

On the other hand, if you have a date format (e.g. '2021/05/19'), you need to convert it to a numeric format. For instance:

```{r 'convert-date'}
## Convert a character to a date object ----
x <- as.Date("2021/05/19")
x

## Convert a date to a numeric (number of days since 1970/01/01) ----
x <- as.numeric(x)
x

## Check ----
as.Date(x, origin = as.Date("1970/01/01"))
```

Other methods exist to convert a `date` to a `numeric` format. You may prefer 
computing the number of days since the first date of your survey. It's up to you.


<br />

**Check `counts` field**

```{r 'check-counts'}
is.numeric(garamba$"counts")   # Are counts in a numerical format?

range(garamba$"counts")        # What is the range of values?

sum(is.na(garamba$"counts"))   # Are there any missing values?
```

Field **`counts`** must be a **positive** `numeric` (zero counts are allowed).
`NA` counts cannot be used for fitting trends. The `format_data()` function (see below) has an option for dropping them.


<br />

**Check `stat_method` field**

```{r 'check-stat'}
unique(garamba$"stat_method")

sum(is.na(garamba$"stat_method"))   # Are there any missing values?
```

Field **`stat_method`** can be either a `character` or a `factor`. It **must**
contain only `T`, `G`, or `S` categories and **cannot** contain any `NA` values.


<br />

**Check `field_method` field**

```{r 'check-field'}
unique(garamba$"field_method")

sum(is.na(garamba$"field_method"))   # Are there any missing values?
```

Field **`field_method`** can be either a `character` or a `factor`. It **must**
contain only `A`, or `T` categories and **cannot** contain any `NA` values.



<br />



## Formatting data

This first `popbayes` function to use is `format_data()`. This function 
provides an easy way to get individual count series ready to be analyzed by 
the package. It must be **used prior to** all other functions.


<br />

First let's define the path (relative or absolute) to save objects/results, namely the formatted count series that can be extracted from the data set.

```{r 'define-path-1', eval = TRUE, echo = FALSE}
path <- tempdir()
```

```{r 'define-path-2', eval = FALSE, echo = TRUE}
path <- "the_folder_to_store_outputs"
```


<br />

The function `format_data()` has many arguments to provide the names of the columns in the user's dataset that contain `location`, `species`, `lower_ci`, etc. By default column names are the same as in the Garamba dataset. If your location field, say, is "site", you'll need to use the argument `location` as follows : 
`location = "site"`.


<br />

```{r 'format-data'}
garamba_formatted <- popbayes::format_data(data = garamba, path = path)
```

<br />


As said above, if you have to add your own count conversion data, you need specify the names of columns for the preferred field method and the conversion factor as this :
`pref_field_method =  "column_with_preferred_field_method"` and 
`conversion_fact = "column_with_conversion_factor"`,
or alternatively use the argument `info` :
`info = "dataframe_with_conversion_info"`.

<br />

Let's explore the output.

```{r 'explore-series'}
## Class of the object ----
class(garamba_formatted)

## Number of elements (i.e. number of counts series) ----
length(garamba_formatted)

## Get series names ----
popbayes::list_series(path)
```

<br />

Let's work with the counts series `"garamba__alcelaphus_buselaphus"`. We can use
the function `filter_series()`.

```{r 'filter-series'}
## Retrieve series by species and location ----
a_buselaphus <- popbayes::filter_series(data     = garamba_formatted, 
                                        species  = "Alcelaphus buselaphus",
                                        location = "Garamba")
```

<br />

Let's display the series content.

```{r 'print-series'}
print(a_buselaphus)
```

<br />

The first elements of the list provide a summary of the count series.

If we compare the two last data frames (`data_original` and `data_converted`), 
they are not identical. The function `format_data()` has **1)** computed 
95% CI boundaries for total counts (coded `T` in the column `stat_method`), and 
**2)** converted all counts (and CI boundaries) to their equivalent in the 
preferred field method (from `A` to `G`) by applying the conversion factor of 
`2.302`.

The Bayesian model will use counts and precision measures from the `data_converted`
data frame.

<br />

Before fitting the model we can visualize the count series with `plot_series()`.

<br />

```{r 'plot-series-1', fig.width=12, fig.height=6, out.width="100%"}
popbayes::plot_series("garamba__alcelaphus_buselaphus", path = path)
```

<br />



The function `format_data()` has also exported the count series as `.RData` files in the `path` folder where they have been dispatched into sub-folders, one per series.


```{r 'list-folder-1', echo = TRUE, eval = FALSE}
list.files(path, recursive = TRUE)
```

```{r 'list-folder-2', echo = FALSE, eval = TRUE}
list.files(path, recursive = TRUE, pattern = "^garamba__")
```


<br />

These `*_data.RData` files (count series) can be imported later by running the function `read_series()`.


```{r 'read-series', eval = FALSE}
a_buselaphus <- popbayes::read_series("garamba__alcelaphus_buselaphus", path = path)
```


<br />



## 4. Fitting Bayesian model


The demographic potential of a species is limited. The intrinsic rate of 
increase `rmax` is the maximum increase in log population size that a species 
can attain in a year.

We strongly recommend providing these `rmax` values while estimating population 
trend to limit yearly population growth estimated by the model.

According to Sinclair (2003), `rmax` is related to the body mass of adult 
females `W`  by the formula:

$$ rmax = 1.375 \times W^{-0.315} $$

Body masses are found in the literature in publications such as Kingdon & 
Hoffman (2013), Cornelis _et al._ (2014), Illius & Gordon (1992), 
Sinclair (1996), Suraud _et al._ (2012), or Foley & Faust (2010). 
Alternatively, `rmax` can be obtained from previous demographic analyses.

<br />

The package `popbayes` provides the `rmax` values for the same 15 African mammals
species listed previously. These values are available in the dataset `rmax_data`.

<br />

```{r 'rmax-data'}
data("rmax_data")
```


**!!! BOOKMARK !!!**


<br />

```{r 'print-data-3', echo = FALSE}
knitr::kable(rmax_data, caption = "Rmax data available in popbayes", 
             align = c("l", "r"))
```









```{r 'run-jags', eval = FALSE}
a_buselaphus_bugs <- popbayes::fit_trend(a_buselaphus, path = path)
```


```{r 'diagnostic', echo = -1}
a_buselaphus_bugs <- popbayes::read_bugs("garamba__alcelaphus_buselaphus", path = "docs/")
diagnostic(a_buselaphus_bugs)
```

```{r 'plot-trend-1',  fig.width=12, fig.height=6, out.width="100%", eval = FALSE, echo = TRUE}
popbayes::plot_trend("garamba__alcelaphus_buselaphus", path = path)
```

```{r 'plot-trend-2',  fig.width=12, fig.height=6, out.width="100%", eval = TRUE, echo = FALSE}
popbayes::plot_trend("garamba__alcelaphus_buselaphus", path = "docs/")
```

<br />

Other functions: `popbayes::read_series()`, `popbayes::list_series()`, 
`popbayes::read_bugs()`, `popbayes::bugs_to_df()`.

...
